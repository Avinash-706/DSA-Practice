 Hashing is a technique primarily used to implement dictionaries (key-value pairs) and sets (unique keys)
 It offers O(1) average time complexity for search, insert, and delete operations, making it highly efficient
 compared to arrays and self-balancing binary search trees


OPERATIONS:

 Search ->  Quickly find a value using a key (e.g., finding details using a phone number)
 Insert ->  Add a key-value pair; if the key exists, the value is updated
 Delete ->  Remove a key and its corresponding value


COMPARISON WITH OTHER DATA STRUCTURES:

                     Arrays                          ->  Sorted arrays provide O(log n) search but slow O(n) insert/delete
                                                         Unsorted arrays allow O(1) insert/delete but slow O(n) search
    Binary Search Trees (BSTs, AVL, Red-Black Trees) ->  Provide O(log n) search, insert, and delete, making them slower than hashing for these operations


LIMITATIONS OF HASHING:

 -> Cannot find closest smaller/larger key efficiently (O(n) time)
 -> Does not maintain sorted order of keys
 -> Inefficient for range queries and prefix searching (Trie is better for prefix searches)
 -> Thus, hashing is an optimal choice when only search, insert, and delete operations are needed without concerns for ordering


APPLICATIONS OF HASHING

1. Dictionary                                 ->   Implementation Used for storing and searching words efficiently in constant time
2. Database Indexing                          ->   Hashing is used for primary and secondary indexing to speed up record retrieval
3. Cryptography                               ->   Passwords are stored as hashed values for security. Authentication is done by comparing stored hashes
4. Caching                                    ->   Used in browser caches, where URLs are keys, and stored data is values
5. Symbol Tables in Compilers                 ->   Helps in quick lookup of variables and addresses in programming languages
6. Networking (Routers & IP Mapping)          ->   Routers use hashing to store MAC addresses and IP mappings for fast retrieval
7. Associative Arrays & Database Operations   ->   Many programming languages use associative arrays (hash tables) for database queries and data storage
8. Other Use Cases                            ->   Hashing is widely used across all fields of computer science for efficient data handling and retrieval


DIRECT ADDRESS TABLE (DAT)

 Direct Address Table is a simple yet efficient technique used in hashing to 
 store and retrieve data in O(1) time complexity for fundamental operations
 
 FEATURES:
  -> Time Complexity: O(1) for Search, Insert, and Delete operations ✅
  -> Uses a Boolean array to mark the presence or absence of elements ✅
  -> Works well when keys are small and within a limited range (e.g., 0 to 999) ✅
  -> Random Access in O(1) time since we directly use the key as an index ✅
 
 LIMITATIONS:
  -> Cannot handle large key values (e.g., phone numbers with 10 digits) ❌
  -> Does not support floating-point numbers or strings as keys ❌
  -> Wastes memory when keys are sparse, as a large array must be allocated even if only a few keys are used ❌
 

HASH MAP (HASH TABLE)

 To overcome DAT's limitations, hashing is introduced, which enables efficient storage
 and retrieval of data even for large keys
 
 Instead of creating a massive array, we use a hash function to map large keys into a fixed-size array
 A hash function (h) takes an input key and returns an array index: h(KEY) = INDEX
 
 This allows storage and retrieval in O(1) average time complexity while significantly reducing memory usage
 
 ADVANTAGES of HASH MAP over DAT:
  -> Can handle large keys, floating-point numbers, and strings efficiently
  -> Requires less memory compared to DAT
  -> Works well for dynamic datasets where keys are not sequential
  -> Supports collision handling techniques like chaining and open addressing for better performance
  
 CHALLENGES with HASHING:
  -> Collisions:                                     Two different keys may produce the same index, requiring additional handling
  -> Performance depends on hash function quality:   A poor hash function may cause clustering, reducing efficiency
