OVERVIEW ON STRINGS

A STRING is a sequence of characters and serves as an essential data structure in programming. Unlike
character arrays, strings come with specialized operations and optimized storage, making them more efficient for text processing


CHARACTER SETS AND ENCODING

 ASCII (American Standard Code for Information Interchange)
  Uses 8-bit encoding (standard: 128 characters, extended: 256 characters)
  Covers English alphabets, digits, punctuation marks, and control characters
 
 UTF-16 (Unicode Transformation Format - 16 bit)
  Stores a larger set of characters to support multiple languages
  First 128 characters are identical to ASCII, ensuring backward compatibility
  Used in Java as the default encoding for characters


STRING REPRESENTATION IN C++ AND JAVA

 C++ Strings
  Uses 8-bit char type for storage
  Standard strings are implemented via std::string
  wchar_t is available for Unicode storage

 Java Strings
  Uses 16-bit char type with UTF-16 encoding
  Stored as immutable objects in String class
  Allows easy conversion between characters and ASCII/Unicode values


CHARACTER VALUE MAPPING

 -> ASCII values of characters:
  'a' -> 97, 'b' -> 98, ..., 'z' -> 122
  'A' -> 65, 'B' -> 66, ..., 'Z' -> 90
   Numeric and special symbols also have specific values

 -> Unicode values:
  First 128 values match ASCII
  Extended characters provide support for multiple languages


STRING OPERATIONS AND ALGORITHMS

 COMMON STRING OPERATIONS

  -> Concatenation
  -> Substring extraction
  -> Length determination
  -> Character access
  -> Comparison

 IMPORTANT STRING ALGORITHMS

  -> Palindrome Check
  -> Subsequence Checking
  -> Anagram Detection
  -> Pattern Searching (Naive, Rabin-Karp, KMP)
  -> Finding Leftmost Repeating & Non-Repeating Characters
  -> Reversing Words in a String
  -> Lexicographic Rank Calculation
  -> Finding the Longest Substring with Distinct Characters


KEY TAKEAWAYS

 -> Strings are more than just character arrays; they have optimized memory and built-in functionalities
 -> ASCII and Unicode provide different ways to represent characters, with UTF-16 supporting a wider range of languages
 -> Java and C++ handle strings differently but maintain fundamental similarities in character value mapping
 -> Understanding string algorithms is crucial for solving competitive programming and real-world problems efficiently


PATTERN SEARCHING IN STRINGS

 The PATTERN SEARCHING PROBLEM involves finding all occurrences of a smaller string (pattern)
 within a larger string (text). If the pattern is not found, the output is "NOT PRESENT"


 EXAMPLE:
  TEXT: geeksforgeeks
  PATTERN: EKS
  OCCURRENCES: Index 2 and 10


 REAL-WORLD USE CASES:
 Searching text in files (e.g., MS Word, programming files)
 Google Search
 DNA Matching
 Regular Expression Matching


 COMMON PATTERN SEARCHING ALGORITHMS
 +-------------------------------------------+-------------------+
 | ALGORITHM                                 | TIME COMPLEXITY   |
 +-------------------------------------------+-------------------+
 | Naive Pattern Searching                   | O((N - M + 1) * M) |
 | Naive (Distinct Characters)               | O(N)              |
 | Rabin-Karp Algorithm                      | O((N - M + 1) * M) |
 | KMP Algorithm                             | O(N)              |
 | Boyer-Moore Algorithm                     | O(N) (Best Case)  |
 | Z Algorithm                               | O(N)              |
 | Suffix Tree (Preprocessing Text)          | O(M) (Search Time)|
 +-------------------------------------------+-------------------+


 OVERVIEW OF KEY ALGORITHMS
  -> NAIVE PATTERN SEARCHING
   Compares the pattern with every substring window of the text
   Time Complexity: O((N - M + 1) * M)
  
  -> NAIVE (WHEN PATTERN CHARACTERS ARE DISTINCT)
   If all characters in the pattern are distinct, the naive approach can be optimized to O(N) time

  -> RABIN-KARP ALGORITHM
   Uses rolling hash to optimize matching
   If the hash matches, only then it checks individual characters
   Best Case: Faster than naive, Worst Case: Similar to naive

  -> KMP ALGORITHM (Knuth-Morris-Pratt)
   Preprocesses the pattern to handle redundancies efficiently
   Uses an LPS (Longest Proper Prefix which is also Suffix) array to avoid redundant comparisons
   Time Complexity: O(N)

  -> BOYER-MOORE ALGORITHM
   Searches the pattern from right to left instead of left to right
   Skips unnecessary comparisons using bad character and good suffix heuristics

  -> SUFFIX TREE (PREPROCESSING TEXT)
   Preprocesses the entire text instead of the pattern
   Ideal for fixed texts where multiple searches are performed
   Searches take O(M) time, where M is the pattern length
   Used in Trie-based searching techniques

 KEY TAKEAWAYS
  -> Pattern Searching is fundamental in text processing and search engines
  -> KMP, Boyer-Moore, and Z algorithms are preferred for efficient searching
  -> Rabin-Karp is useful when multiple pattern searches are required
  -> Suffix Trees are efficient when the text is fixed, allowing quick searches

RABIN-KARP ALGORITHM & IMPROVED HASHING
 The Rabin-Karp Algorithm is a string matching algorithm that utilizes hashing to
 efficiently search for a pattern in a text. Instead of checking every substring
 individually, it compares hash values, making it significantly faster in average cases

 KEY CONCEPT
 -> Compute the hash of the pattern and the hash of substrings in the text
 -> If the hash values match, perform a character-by-character verification
 -> Uses a rolling hash function to efficiently update the hash value for new substrings
 
 USE CASES
  Text searching in large documents ✅ 
  Plagiarism detection ✅ 
  Searching for multiple patterns efficiently ✅ 
  NA sequencing and bioinformatics applications ✅ 